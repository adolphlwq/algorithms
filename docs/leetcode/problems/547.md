# 547. 朋友圈
我的思路是dfs，但是我不清楚如何构造深搜以及返回值来确定朋友圈的个数。最好思路卡在dfs的构造和返回值上：
```cpp
class Solution {
public:
    bool dfs(vector<vector<int>>& M, int i, int j) {
        if(i>j || i<0 || i>=M.size() || j<0 || j>=M[0].size())
    }
    int findCircleNum(vector<vector<int>>& M) {
        int row=M.size(), col=M[0].size();
        int i, j, res=0;
        for(i=0; i<row; i++) {
            for(j=i; j<col; j++)
                if(dfs(M, i, j)) ret++;
        }

        return ret;
    }
};
```

下面的代码是参考官方题解得到的，自己看了下还是不能理解，因为M的N*N的方阵，所以循环中的上限都是M.size()表示的。
但是官方的思路需要借鉴，**把问题转化成求连通图的个数**，从这个角度入手好理解了些。理解代码的关键是代码如何实现深搜。
```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& M, vector<int>& visited, int i) {
        for(int j=0; j<M.size(); j++)
            if(M[i][j]==1 && visited[j]==0) {
                visited[j] = 1;
                dfs(M, visited, j);
            }
    }
    
    int findCircleNum(vector<vector<int>>& M) {
        vector<int> visited(M.size(), 0);
        int i, cnt=0;
        for(i=0; i<M.size(); i++)
            if(visited[i] == 0) {
                dfs(M, visited, i);
                cnt++;
            }
        
        return cnt;
    }
};
```

广度优先搜索
```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        vector<int> visited(M.size(), 0);
        queue<int> q;
        int i, cnt=0;
        for(i=0; i<M.size(); i++)
            if(visited[i] == 0) {
                q.push(i);
                while(!q.empty()) {
                    int s = q.front();
                    q.pop();
                    visited[s] = 1;
                    for(int j=0; j<M.size(); j++)
                        if(M[s][j]==1 && visited[j]==0)
                            q.push(j);
                }
                cnt++;
            }
        
        return cnt;
    }
};
```